### YamlMime:QSharpType
uid: microsoft.quantum.canon.ampampobliviousbyoraclephases
name: AmpAmpObliviousByOraclePhases
type: function
namespace: Microsoft.Quantum.Canon
summary: >2
   Oblivious amplitude amplification by oracles for partial reflections.
remarks: " This imposes stricter conditions on form of the ancilla start and target states than in \"AmpAmpObliviousByReflectionPhases\".\n It is assumed that $A\\ket{0}\\_f\\ket{0}\\_a= \\ket{\\text{start}}_{fa}$ prepares the ancilla start state $\\ket{\\text{start}}_{fa}$ from the computational basis $\\ket{0}\\_f\\ket{0}$.\n It is assumed that the target state is marked by $\\ket{1}_f$.\n It is assumed that     \n $$\n O\\ket{\\text{start}}\\_{fa}\\ket{\\psi}\\_s= \\lambda\\ket{1}\\_f\\ket{\\text{anything}}_a\\ket{\\text{target}}\\_s U \\ket{\\psi}\\_s + \\sqrt{1-|\\lambda|^2}\\ket{0}\\_f\\cdots,\n $$\n for some unitary $U$.\n In most cases, \"flagQubit\" and \"ancillaRegister\" are initialized in the state $\\ket{0}\\_f\\ket{0}\\_a$."
syntax: 'function AmpAmpObliviousByOraclePhases (phases : AmpAmpReflectionPhases, ancillaOracle : DeterministicStateOracle, signalOracle : ObliviousOracle, idxFlagQubit : Int) : ((Qubit[], Qubit[]) => () : Adjoint, Controlled)'
input:
  content: '(phases : AmpAmpReflectionPhases, ancillaOracle : DeterministicStateOracle, signalOracle : ObliviousOracle, idxFlagQubit : Int)'
  types:
  - name: ancillaOracle
    uid: deterministicstateoracle
    content: deterministicstateoracle
  - name: idxFlagQubit
    isPrimitive: true
  - name: phases
    uid: ampampreflectionphases
    content: ampampreflectionphases
  - name: signalOracle
    uid: obliviousoracle
    content: obliviousoracle
output:
  content: '((Qubit[], Qubit[]) => () : Adjoint, Controlled)'
  types:
  - isOperation: true
    types:
    - types:
      - isPrimitive: true
        isArray: true
      - isPrimitive: true
        isArray: true
    - isPrimitive: true
